package oop.ex6.parser;

import oop.ex6.executer.Executor;
import oop.ex6.members.Parameter;
import oop.ex6.members.Value;
import oop.ex6.members.Variable;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.function.ToIntFunction;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * This class represents a parser which parses an s-java file.
 */
public class Parser {

    /*----=   Constants  =----*/

    // Constants representing reserved s-java words.
    private static final String FINAL = "final ";
    private static final String IF = "if";
    private static final String WHILE = "while";
    private static final String INT = "int ";
    private static final String CHAR = "char ";
    private static final String STRING = "String ";
    private static final String BOOLEAN = "boolean ";
    private static final String DOUBLE = "double ";
    private static final String VOID = "void ";
    private static final String RETURN = "return";

    private static final String[] RESERVED_WORDS =
            {FINAL, IF, WHILE, INT, CHAR, STRING, BOOLEAN, DOUBLE, VOID, RETURN};

    // Constants representing reserved s-java operators.
    private static final String RIGHT_BRACE = "}";
    private static final String LEFT_BRACE = "{";
    private static final String AND = "&&";
    private static final String OR = "||";
    private static final String COMMA = ",";
    private static final String SEMICOLON = ";";
    private static final String RIGHT_PARENTHESIS = ")";
    private static final String LEFT_PARENTHESIS = "(";
    private static final String EQUAL_SIGN = "=";

    // Regex bank:
    private static final String whitespace = "\\s*+";
    private static final String start = "^";
    private static final String intRegex = start+"-?+\\d++";
    private static final String stringRegex = start+"\""+whitespace+".*"+whitespace+"\"";
    private static final String booleanRegex = start+"true|false";
    private static final String charRegex = start+"\'"+whitespace+"."+whitespace+"\'";
    private static final String doubleRegex = start+intRegex+"\\."+"\\d++";
    private static final String variableNameRegex = start+"(?:[a-zA-Z]|_\\w)\\w*+";
    private static final String methodNameRegex = start+"[a-zA-Z]\\w*+";
    private static final String commentRegex = start+"//";

    // Pattern bank corresponding to the regex bank.
    private static final Pattern intPattern = Pattern.compile(intRegex);
    private static final Pattern stringPattern = Pattern.compile(stringRegex);
    private static final Pattern booleanPattern = Pattern.compile(booleanRegex);
    private static final Pattern charPattern = Pattern.compile(charRegex);
    private static final Pattern doublePattern = Pattern.compile(doubleRegex);
    private static final Pattern variableNamePattern = Pattern.compile(variableNameRegex);
    private static final Pattern methodNamePattern = Pattern.compile(methodNameRegex);
    private static final Pattern commentPattern = Pattern.compile(commentRegex);

    // Corresponding arrays which list for each variable type:
    // 1. its toString() output.
    // 2. the variable type.
    // 3. the regex pattern which matches its legal input value.
    private static final String[] types = {CHAR, STRING, BOOLEAN, DOUBLE, INT};
    private static final Variable.Type[] variableTypes = {
            Variable.Type.CHAR,
            Variable.Type.STRING,
            Variable.Type.BOOLEAN,
            Variable.Type.DOUBLE,
            Variable.Type.INT
    };
    private static final Pattern[] typePatterns = {
            charPattern,
            stringPattern,
            booleanPattern,
            doublePattern,
            intPattern
    };

    // Magic numbers.
    private static final int falseResult = -1;
    private static final int EXPECTED_COMMAND_LINE_LENGTH = 1;

    // Formats for parser IO and syntax exceptions that are generated by this class.
    private static final String EXPECTED = "expected - '";
    private static final String FOUND = "', found - '";
    private static final String ORString = "' or '";
    private static final String VARIABLE_NAME = "variable name expected.";
    private static final String METHOD_NAME = "method name expected";
    private static final String RESERVED_WORD =" is a reserved word, and not a valid variable or method name";
    private static final String VARIABLE_TYPE = "variable type expected.";
    private static final String VALID_VALUE = "valid value expected.";
    private static final String VERIFY_END = "unexpected token. One argument is expected in each line.";
    private static final String PARSE_FAIL = "failed to parse code line.";
    private static final String NUMBER_OF_ARGUMENTS = "single command line argument expected.";
    private static final String SOURCE_FILE_NAME = "bad source-file name.";

    /*----=   Instance Data Members  =----*/

    private String currentLine;
    private String originalLine;
    private int lineNumber;
    private ArrayList<CodeLine> globalScopeCommands;
    private ArrayList<CodeLine> localScopeCommands;
    private ArrayList<CodeLine> currentCommands;
    private int braceCounter;

     /*----=   Constructor  =----*/

    /**
     * The default constructor.
     */
    public Parser(){
        this.lineNumber = 0;
        this.globalScopeCommands = new ArrayList<>();
        this.localScopeCommands = new ArrayList<>();
        this.currentCommands = this.globalScopeCommands;
        this.braceCounter = 0;
    }

    /*----=   Instance Methods: 1. String Modifiers & Parsers  =----*/

    /**
     * @param reservedWord - the provided word;
     * @return if the provided word is the next word in the current line, the offset after the last matched
     * character; -1 otherwise.
     */
    private int nextWordIs(String reservedWord){
        if (this.currentLine.startsWith(reservedWord)){
            return reservedWord.length();
        }
        return falseResult;
    }

    /**
     * @param reservedWords - the provided words;
     * @return if one of the provided words is the next word in the current line, the offset after the last
     * matched character; -1 otherwise.
     */
    private int nextWordIs(String[] reservedWords){
        int result;
        for (String reservedWord: reservedWords) {
            result = this.nextWordIs(reservedWord);
            if (result != falseResult) {
                return result;
            }
        }
        return falseResult;
    }

    /**
     * @param pattern - the provided pattern;
     * @return if the provided pattern matches the next word in the current line -  the offset after the last
     * matched character; -1 otherwise.
     */
    private int nextWordIs(Pattern pattern){
        Matcher matcher = pattern.matcher(this.currentLine);
        if (matcher.find()){
            return matcher.end();
        }
        return falseResult;
    }

    /**
     * @param word the provided word
     * @return true if the provided word matches any of s-java's reserved words; false otherwise.
     */
    private boolean isReserved(String word) {
        for (String reservedWord: RESERVED_WORDS){
            if (word.equals(reservedWord.trim())){
                return true;
            }
        }
        return false;
    }

    /**
     * Omit from the current line any character up to the given index, and trailing whitespace.
     * @param beginIndex - the provided index.
     */
    private void trimCurrentLine(int beginIndex){
        this.currentLine = this.currentLine.substring(beginIndex).trim();
    }

    /*----=   Instance Methods: 2. 'Command Factory' Helper Methods  =----*/

    /**
     * Scan the next word in the current line - the given reserved word.
     * @param reservedWord - the given reserved word.
     * @throws ParserSyntaxException - if the next word in the current line is not the expected word.
     */
    private void scan(String reservedWord) throws ParserSyntaxException {
        int result = this.nextWordIs(reservedWord);
        if (result == falseResult){
            String found = this.originalLine.substring(this.originalLine.length()-this.currentLine.length());
            throw new ParserSyntaxException(EXPECTED+reservedWord+FOUND+found+"'.", this.lineNumber);
        }
        this.trimCurrentLine(result);
    }

    /**
     * Scan the next word in the current line - one of the given reserved words.
     * This method assumes the given array is not null or empty.
     * @param reservedWords - the array of given reserved words.
     * @throws ParserSyntaxException - if the next word in the current line is not one of the expected word.
     */
    private void scan(String[] reservedWords) throws ParserSyntaxException {
        int result = this.nextWordIs(reservedWords);
        if (result == falseResult){
            String errorMessage = EXPECTED+reservedWords[0];
            for (int i=1; i<reservedWords.length-1;i++){
                errorMessage = errorMessage+"', '"+reservedWords[i];
            }
            if (reservedWords.length > 1){
                errorMessage = errorMessage +ORString+reservedWords[reservedWords.length-1];
            }
            String found = this.originalLine.substring(this.originalLine.length()-this.currentLine.length());
            errorMessage = errorMessage + FOUND+found+"' .";
            throw new ParserSyntaxException(errorMessage, this.lineNumber);
        }
        this.trimCurrentLine(result);
    }

    /**
     * @return true if scanned a final modifier; false otherwise.
     */
    private boolean isFinal() {
        boolean isFinal = false;
        int result = this.nextWordIs(FINAL);
        if (result != falseResult){
            isFinal = true;
            this.trimCurrentLine(result);
        }
        return isFinal;
    }

    /**
     * Get the next word in the current line - a variable name.
     * @return the variable name.
     * @throws ParserSyntaxException - if the next word in the current line is not a legal variable name.
     */
    private String getVariableName() throws ParserSyntaxException {
        int result = this.nextWordIs(variableNamePattern);
        if (result == falseResult){
            throw new ParserSyntaxException(VARIABLE_NAME, this.lineNumber);
        }
        String variableName = this.currentLine.substring(0, result);
        this.trimCurrentLine(result);
        if (this.isReserved(variableName)){
            throw new ParserSyntaxException(variableName+RESERVED_WORD, this.lineNumber);
        }
        return variableName;
    }

    /**
     * Get the next word in the current line - a method name.
     * @return the method name.
     * @throws ParserSyntaxException - if the next word in the current line is not a legal method name.
     */
    private String getMethodName() throws ParserSyntaxException {
        int result = this.nextWordIs(methodNamePattern);
        if (result == falseResult){
            throw new ParserSyntaxException(METHOD_NAME, this.lineNumber);
        }
        String methodName = this.currentLine.substring(0, result);
        this.trimCurrentLine(result);
        if (this.isReserved(methodName)){
            throw new ParserSyntaxException(methodName+RESERVED_WORD, this.lineNumber);
        }
        return methodName;
    }

    /**
     * Get the next word in the current line - a variable type.
     * @return the variable type.
     * @throws ParserSyntaxException - if the next word in the current line is not a legal variable type.
     */
    private Variable.Type getVariableType() throws ParserSyntaxException {
        int result;
        for (int i=0; i<types.length; i++){
            result = this.nextWordIs(types[i]);
            if (result != falseResult){
                this.trimCurrentLine(result);
                return variableTypes[i];
            }
        }
        throw new ParserSyntaxException(VARIABLE_TYPE, this.lineNumber);
    }

    /**
     * Get the next word in the current line - a value. A value is either a legal input value for a variable
     * type or a variable reference.
     * @return the value.
     * @throws ParserSyntaxException - if the next word in the current line is not a legal value.
     */
    private Value getValue() throws ParserSyntaxException {
        int result;
        for (int i=0; i<typePatterns.length; i++){
            result = this.nextWordIs(typePatterns[i]);
            if (result != falseResult){
                this.trimCurrentLine(result);
                return new Value(variableTypes[i]);
            }
        }
        if (this.nextWordIs(variableNamePattern) == falseResult){
            throw new ParserSyntaxException(VALID_VALUE, this.lineNumber);
        }
        return new Value(this.getVariableName());
    }

    /**
     * Get the next words in the current line - an listing of values. The number of values can be 0.
     * @return the values.
     * @throws ParserSyntaxException - if the listing of values has an illegal syntax i.e. illegal delimiters
     * or illegal value inputs.
     */
    private ArrayList<Value> getValues() throws ParserSyntaxException {
        ArrayList<Value> values = new ArrayList<>();
        while (this.nextWordIs(RIGHT_PARENTHESIS) == falseResult){
            if (values.size()>0){
                this.scan(COMMA);
            }
            values.add(this.getValue());
        }
        return values;
    }

    /**
     * Get the next words in the current line - an listing of conditions. The number of values must be
     * greater than 0.
     * @return the conditions.
     * @throws ParserSyntaxException - if the listing of conditions has an illegal syntax i.e. illegal
     * delimiters or illegal condition inputs.
     */
    private ArrayList<Value> getConditions() throws ParserSyntaxException {
        ArrayList<Value> values = new ArrayList<>();
        values.add(this.getValue());
        String[] delimiters = {AND, OR};
        while (this.nextWordIs(RIGHT_PARENTHESIS) == falseResult){
            this.scan(delimiters);
            values.add(this.getValue());
        }
        return values;
    }

    /**
     * Get the next words in the current line - a parameter.
     * @return the parameter.
     * @throws ParserSyntaxException - if the next word in the current line is not a legal parameter.
     */
    private Parameter getParameter() throws ParserSyntaxException {
        boolean isFinal = this.isFinal();
        Variable.Type parameterType = this.getVariableType();
        String parameterName = this.getVariableName();
        return new Parameter(isFinal, parameterType, parameterName);
    }

    /**
     * Get the next words in the current line - an listing of parameters. The number of values can be 0.
     * @return the parameters.
     * @throws ParserSyntaxException - if the listing of parameters has an illegal syntax i.e. illegal
     * delimiters or illegal parameter inputs.
     */
    private ArrayList<Parameter> getParameters() throws ParserSyntaxException {
        ArrayList<Parameter> parameters = new ArrayList<>();
        while (this.nextWordIs(RIGHT_PARENTHESIS) == falseResult){
            if(parameters.size()>0){
                this.scan(COMMA);
            }
            parameters.add(this.getParameter());
        }
        return parameters;
    }

    /**
     * Verify that no unexpected tokens appear after the command suffix.
     * @throws ParserSyntaxException - if the verification failed.
     */
    private void verifyEndOfLine() throws ParserSyntaxException {
        if(!this.currentLine.isEmpty()){
            throw new ParserSyntaxException(VERIFY_END, this.lineNumber);
        }
    }

    /**
     * Add a new code line to the current commands scope.
     * @param command - the command to be added.
     */
    private void addCommandLine(ToIntFunction<Executor> command){
        CodeLine codeLine = new CodeLine(command, this.lineNumber);
        this.currentCommands.add(codeLine);
    }

    /*----=   Instance Methods: 3. 'Command Factory' Methods  =----*/

    /**
     * Parse a variable definition line and add the corresponding command to the current commands array.
     * @throws ParserSyntaxException - if the line's syntax is illegal.
     */
    private void defineMultipleVariables() throws ParserSyntaxException {
        boolean isFinal = this.isFinal();
        Variable.Type variableType = this.getVariableType();
        this.defineVariables(isFinal, variableType);
        while (this.nextWordIs(SEMICOLON) == falseResult){
            this.scan(COMMA);
            this.defineVariables(isFinal, variableType);
        }
        this.scan(SEMICOLON);
        this.verifyEndOfLine();
    }

    /**
     * Helper method to defineMultipleVariables() which parses the next words in the current line - a
     * variable name, and potentially a value assignment - and adds a variable definition command to the
     * current commands array.
     * @param isFinal - the variable's final modifier.
     * @param variableType - the variable's type.
     * @throws ParserSyntaxException - if the line's syntax is illegal.
     */
    private void defineVariables(boolean isFinal, Variable.Type variableType)
            throws ParserSyntaxException {
        String variableName = this.getVariableName();
        Value tempValue = null;
        if (this.nextWordIs(EQUAL_SIGN) != falseResult){
            this.scan(EQUAL_SIGN);
            tempValue = this.getValue();
        }
        Value value = tempValue;

        ToIntFunction<Executor> command = Executor -> Executor.defineVariable(isFinal, variableType, variableName, value);
        this.addCommandLine(command);
    }

    /**
     * Parse a value assignment line and add the corresponding command to the current commands array.
     * @throws ParserSyntaxException - if the line's syntax is illegal.
     */
    private void assignValue() throws ParserSyntaxException {
        String variableName = this.getVariableName();
        this.scan(EQUAL_SIGN);
        Value value = this.getValue();

        ToIntFunction<Executor> command = Executor -> Executor.assignValue(variableName, value);
        this.addCommandLine(command);

        this.scan(SEMICOLON);
        this.verifyEndOfLine();
    }

    /**
     * Parse a method call line and add the corresponding command to the current commands array.
     * @throws ParserSyntaxException - if the line's syntax is illegal.
     */
    private void callMethod() throws ParserSyntaxException {
        String methodName = this.getMethodName();
        this.scan(LEFT_PARENTHESIS);
        ArrayList<Value> values = this.getValues();
        this.scan(RIGHT_PARENTHESIS);

        ToIntFunction<Executor> command = Executor -> Executor.callMethod(methodName, values);
        this.addCommandLine(command);

        this.scan(SEMICOLON);
        this.verifyEndOfLine();
    }

    /**
     * Parse a return statement and add the corresponding command to the current commands array.
     * @throws ParserSyntaxException - if the line's syntax is illegal.
     */
    private void sendReturnStatement() throws ParserSyntaxException {
        this.scan(RETURN);

        ToIntFunction<Executor> command = Executor::sendReturnStatement;
        this.addCommandLine(command);

        this.scan(SEMICOLON);
        this.verifyEndOfLine();
    }

    /**
     * Parse a method declaration line and add the corresponding command to the current commands array;
     * change current commands array to local and add an open method scope command.
     * @throws ParserSyntaxException - if the line's syntax is illegal.
     */
    private void openMethodDeclaration() throws ParserSyntaxException {
        this.scan(VOID);
        String methodName = this.getMethodName();
        this.scan(LEFT_PARENTHESIS);
        ArrayList<Parameter> parameters = this.getParameters();
        this.scan(RIGHT_PARENTHESIS);

        ToIntFunction<Executor> command = Executor -> Executor.declareMethod(methodName, parameters);
        this.addCommandLine(command);

        this.scan(LEFT_BRACE);
        this.verifyEndOfLine();

        this.braceCounter++;
        this.currentCommands = this.localScopeCommands;
        command = Executor -> Executor.openMethodScope(methodName);
        this.addCommandLine(command);
    }

    /**
     * Parse an if/while statement and add the corresponding command to the current commands array.
     * @throws ParserSyntaxException - if the line's syntax is illegal.
     */
    private void openIfWhileBlock() throws ParserSyntaxException {
        String[] ifWhile = {IF, WHILE};
        this.scan(ifWhile);
        this.scan(LEFT_PARENTHESIS);
        ArrayList<Value> conditions = this.getConditions();
        this.scan(RIGHT_PARENTHESIS);

        ToIntFunction<Executor> command = Executor -> Executor.openIfWhileScope(conditions);
        this.addCommandLine(command);

        this.scan(LEFT_BRACE);
        this.verifyEndOfLine();

        this.braceCounter++;
    }

    /**
     * Parse a close block statement and add the corresponding command to the current commands array;
     * if reached global scope - change current commands array to global.
     * @throws ParserSyntaxException - if the line's syntax is illegal.
     */
    private void closeBlock() throws ParserSyntaxException {
        ToIntFunction<Executor> command = Executor::closeScope;
        this.addCommandLine(command);

        this.scan(RIGHT_BRACE);
        this.verifyEndOfLine();

        this.braceCounter--;
        if (this.braceCounter == 0){
            this.currentCommands = this.globalScopeCommands;
        }
    }

    /*----=   Instance Methods: 4. File Parsing Methods  =----*/


    /**
     * Direct the current line to be parsed by one of the "command factory" parsing methods.
     * @throws ParserSyntaxException - if this method failed to categorize the current line, or if the
     * parsing methods received a line with illegal syntax.
     */
    private void parseCurrentLine() throws ParserSyntaxException {
        if (this.nextWordIs(commentPattern) != falseResult){
            return;
        }
        if (this.currentLine.trim().isEmpty()){
            return;
        }

        this.currentLine = this.currentLine.trim();
        String testLine = this.currentLine.trim().replace(" ", "");

        if (testLine.endsWith(LEFT_BRACE)){
            if ((testLine.contains(IF))||(testLine.contains(WHILE))){
                this.openIfWhileBlock();
                return;
            }
            this.openMethodDeclaration();
            return;
        }
        if (testLine.endsWith(RIGHT_BRACE)){
            this.closeBlock();
            return;
        }
        if (testLine.endsWith(SEMICOLON)){
            String[] defineVariablePrefixes = {FINAL, INT, STRING, CHAR, DOUBLE, BOOLEAN};
            for (String prefix: defineVariablePrefixes){
                if (testLine.contains(prefix.trim())){
                    this.defineMultipleVariables();
                    return;
                }
            }
            if (testLine.contains(EQUAL_SIGN)){
                this.assignValue();
                return;
            }
            if (testLine.contains(RETURN)){
                this.sendReturnStatement();
                return;
            }
            if ((testLine.contains(LEFT_PARENTHESIS)) &&
                    (testLine.substring(testLine.indexOf(LEFT_PARENTHESIS)).contains(RIGHT_PARENTHESIS))){
                this.callMethod();
                return;
            }
        }
        throw new ParserSyntaxException(PARSE_FAIL, this.lineNumber);

    }

    /**
     * Verify that the given command line arguments array has the correct number of arguments.
     * @param args - the command line arguments
     * @throws ParserIOException - if the verification failed.
     */
    private void verifyCommandLineArgument(String[] args) throws ParserIOException {
        if (args.length != EXPECTED_COMMAND_LINE_LENGTH){
            throw new ParserIOException(NUMBER_OF_ARGUMENTS);
        }
    }

    /**
     * Parse the given s-java file and return an array of commands representing the s-java file's code.
     * @param args - the s-java file's source name.
     * @return - the array of commands.
     * @throws ParserSyntaxException - if parser encountered a syntax error in the s-java file.
     * @throws ParserIOException - if parser encountered an IO exception while parsing the s-java file.
     */
    public ArrayList<CodeLine> getCommands(String[] args)  throws ParserSyntaxException, ParserIOException {
        this.verifyCommandLineArgument(args);
        try (BufferedReader bufferedReader = new BufferedReader(new FileReader(args[0]))){
            this.currentLine = bufferedReader.readLine();
            while (this.currentLine != null){
                this.originalLine = this.currentLine;
                this.lineNumber ++;
                this.parseCurrentLine();
                this.currentLine = bufferedReader.readLine();
            }
            ArrayList<CodeLine> commands = this.globalScopeCommands;
            commands.addAll(this.localScopeCommands);
            return commands;
        }
        catch (IOException e){
            throw new ParserIOException(SOURCE_FILE_NAME);
        }
    }










}
